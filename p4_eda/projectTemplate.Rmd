---
title: "Exploratory Data Analysis in R"
author: "Ivailo Kassamakov"
date: "February 5, 2016"
output: html_document
---
========================================================

```{r global_options, include=FALSE} 

knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)

```


```{r packages}
# Load all of the packages that you end up using
# in your analysis in this code chunk.

# Notice that the parameter "echo" was set to FALSE for this code chunk.
# This prevents the code from displaying in the knitted HTML output.
# You should set echo=FALSE for all code chunks in your file.

library(ggplot2)
library(gridExtra)
library(dplyr)
library(GGally)
library(corrgram)
library(car) # for powerTransform and bcPower
library(MASS) # boxcox and ologit (polr)
```

# Abstract
This project is an effort towards partial fulfilment of the requirements for the Udacity's Data Analyst Nanodegree.

The purpose is to perform an Exploratory Data Analysis (mono-, bi- and multivariate) on a dataset containing physicochemical measurements and tasting results of a sample of red wines.

# Goal of the data analysis
Our goal with this dataset is to investigate how the chemical qualities of the wine affect its quality. Ideally, we would be able to come up with a regression model that will enable us to predict the quality of wine given its chemical properties.

As the authors of the dataset mention in their notes, it is possible that there are correlations between some of the measured quantities. Therefore, in the course of our work we will try to detect any such interactions between the variables.

# Dataset loading and some preliminary cleaning

We start by loading the dataset (stored in a CSV file) into a data.frame:


```{r Load_the_Data}
# Load the Data
w <- read.csv("wineQualityReds.csv")
```

Some information about the number and the structure of the observations
```{r Dataset_structure}
str(w)
```

We see that there are 1599 observation of wines, each one containing 13 variables. We can safely remove the "X" column as it simply repeats the natural index of the observations. 
```{r Removing_X_column}
w$X <- NULL
```
The rest of the variables are numeric. This is valid for most of them, since they are results of laboratory measurements. However, the "quality" variable is the tasting result, which is categorical variable having an ordinal scale. Therefore, we can convert this variable to an ordered factor, assuming that a higher number indicates a higher quality.

```{r Converting_quality_to_factor}
w$quality <- factor(w$quality, ordered = T)
str(w)
```

In this last "str" output we clearly see that "quality" is now represented by a 6-level ordered factor with the following levels:

```{r quality_levels}
levels(w$quality)
```

We test the data for any missing (NA) or numerically bad (NaN) data--there is no such data (`r all(!is.na(w))`).

Otherwise, the dataset is already in a **"tidy"** state--a row per observation, with all observation attributes in separate columns. 

# Univariate Plots Section
In this section we perform initials statistical and graphical analysis of the variables contained in the dataset.

In the plots below, the red vertical lines correspond to the median value of the variable, while the brown dashed vertical lines mark the 95% percentile of the data.


## Fixed acidity
```{r Uniplot_fixed_acidity}

plotVar <- function(v,d) {
  name <- deparse(substitute(v))
  q1 <- qplot(data=d, x=v, fill=I("blue"), color=I("black"), alpha=0.5, xlab=name) + 
        theme(legend.position="none") + geom_vline(aes(xintercept=median(v)), color="red") +
        geom_vline(aes(xintercept=quantile(v,0.95)), color="orange", linetype="dashed")

  q2 <- qplot(data=d, x=v, geom="density", xlab=name, fill=I("blue"), alpha=0.5) + 
		    geom_rug() + geom_vline(aes(xintercept=median(v)), color="red") +
        geom_vline(aes(xintercept=quantile(v,0.95)), color="orange", linetype="dashed") + 
        theme(legend.position="none")

  q3 <- qplot(0, data=d, y=v, geom="boxplot", ylab=name) + 
		theme(axis.title.x=element_blank())

  grid.arrange(q1, q2, q3, layout_matrix=matrix(c(1,2,3,3), 2, 2))
}

summary(w$fixed.acidity)
plotVar(w$fixed.acidity, w)
```

```{r useful_functions}
# Pearsonâ€™s measure of kurtosis
kurtosis <- function(x) {
	n <- length(x)
	z <- (x - mean(x)) / sd(x)
	sum(z^4)/n - 3
}

# Pearson's moment coefficient of skewness
skewness <- function(x) {
  n <- length(x)
  z <- (x - mean(x)) / sd(x)
  sum(z^3)/n
}
```

The *fixed acidity* features somewhat normal distribution with some right-skewedness (skewness = `r skewness(w$fixed.acidity)`) and relatively long tail (excess kurtosis = `r kurtosis(w$fixed.acidity)`).  

The boxplot identifies many values as outliers.

## Volatile acidity
```{r Uniplot_volatile_acidity}
summary(w$volatile.acidity)
plotVar(w$volatile.acidity, w)
```

The *volatile.acidity* has a similar right-skewed distribution (skewness = `r skewness(w$volatile.acidity)`) and a similarly long tail (kurtosis = `r kurtosis(w$volatile.acidity)`). 

The distribution seems a bit multi-modal. We can see this on a higher-resolution histogram.

```{r Uniplot_volatile_acidity_hires}

qplot(data=w, x=volatile.acidity, fill=I("blue"), color=I("black"), alpha=0.5,
	  binwidth = 0.01) + 
      theme(legend.position="none")
```

The boxplot again identifies several values as outliers. 

## Citric acid
```{r Uniplot_citric_acid}
summary(w$citric.acid)
plotVar(w$citric.acid, w)
```

The *citric.acid* variable has many values equal to 0, as well as one value equal to 1 (also shown by the boxplot as an outlier). This outlier can be either a data entry error, or a wine that has excessive amount of citric acid (more than the limit of the measuring instrument). 

As the value table below shows, the resolution of the measurement has been only 0.01 g/dm^3^, which means that all wines containing less than that will appear as 0 in the dataset.

```{r Uniplot_citric_acid_table}
table(w$citric.acid)
```

We can get a better idea about the distribution by eliminating values 0 and 1. We will also adjust the `binwidth` to correspond to the measurement resolution.

```{r Uniplot_citric_acid_cleaned}
cleaned.citric.acid = subset(w, citric.acid != 0 & citric.acid != 1)

q1 <- qplot(data=cleaned.citric.acid, x=citric.acid, binwidth=0.01, 
			fill=I("blue"), color=I("black"), alpha=0.5) + 
			theme(legend.position="none")
	  
q2 <- qplot(data=cleaned.citric.acid, x=citric.acid, geom="density") + geom_rug()

grid.arrange(q1, q2, nrow=2)
```

This distribution appears **artificially** uniform towards the lower values (i.e. there is no gradual reduction of the frequency of the lower values). This can be probably explained with the fact that the winemakers usually add some amount of citric acid to give the wine a fresh (non-flat) body. Further confirmation for this is the presence of three very prominent peaks in the histogram (at 0.02, 0.24 and 0.49); especially the last two can signify that the citric amount has been artificially boosted to 0.25 or 0.50. If the citric acid amounts were due to a *natural process* (like fermentation, as is the case with the other acids), then its distribution would be more *bell-shaped* (the central limit theorem calls for normal distribution of the combined effect of many random processes.)

## Residual sugar
```{r Uniplot_residual_sugar}
summary(w$residual.sugar)
plotVar(w$residual.sugar, w)
```

The IQR range (`r IQR(w$residual.sugar)`) of the *residual.sugar* values is pretty small compared to the total range (`r diff(range(w$residual.sugar))`). This signifies that we're dealing with wines of mostly the same class of sweetness; which is not surprising given that the *"Vinho Verde"* region produces predominantly very fresh wines.

We can classify the wines in terms of sweetness according to the scale mandated by EU directive 753/2002. This scale runs like this:

Sugar content [g/dm^3^] | < 4 |  (4, 12]   |  (12, 45] | > 45
------------------------|-----|------------|-----------|------
Sweetness               | Dry | Medium Dry |    Medium | Sweet

We create a new ordered factor called `sweetness` in the original dataframe having levels corresponding to the sweetness degrees above. As the frequency table below shows most of the wines are "dry".

```{r Uniplot_sweetness_bins}
w$sweetness <- cut(w$residual.sugar, 
					c(0,4,12,45, Inf), 
					labels=c("dry", "medium.dry", "medium", "sweet"), 
					ordered_result=T)
					
table(w$sweetness)
```

## Chlorides
```{r Uniplot_chlorides}
summary(w$chlorides)
plotVar(w$chlorides, w)
```

The amount of NaCl (*chlorides*) also shows a bell-shaped distribution with a long tail (excess kurtosis = `r kurtosis(w$volatile.acidity)`). Most values are again concentrated in a small region (IQR=`r IQR(w$chlorides)` compared to range=`r diff(range(w$residual.sugar))`). This can be explained by the fact that all wines come from a geographically constrained region; it is known that the soil type and micro-climatic conditions of the region have direct influence on the salinity of the wine. Interestingly, some countries limit the amount of chlorides accepted in a wine (e.g. in Brazil it is 0.2 g/dm^3^, while in Australia it is 0.6 g/dm^3^). Generally, levels above 0.5 g/dm^3^ start to give the sensory perception of saltiness (although it depends on the national diet). There is one "outlier" wine in the sample that can trigger a "salty" grimace of the taster.


## Free SO~2~
```{r Uniplot_freeSO2}
summary(w$free.sulfur.dioxide)
plotVar(w$free.sulfur.dioxide, w)
```

The winemakers use SO~2~ as an antioxidant and disinfectant. Before bottling the wine they adjust the levels of free SO~2~ usually between 10 and 40 mg/dm^3^ (careful producers relate the amount of SO~2~ to the pH--red wines with low pH need less SO~2~ than ones with higher pH). This range is also pretty visible in the histogram above.


## Total SO~2~
```{r Uniplot_totalSO2}
summary(w$total.sulfur.dioxide)
plotVar(w$total.sulfur.dioxide, w)
```

In Europe the permitted level of total SO~2~ is 150 mg/dm^3^ for dry red wines (200 mg/dm^3^ for sugar levels above 5 g/dm^3^). This requirement is also visible from the graphs above. There are two wines that surpass significantly this limit (theoretically they can't be sold on the EU market, but this is possible for the US where the permitted level is 300 mg/dm^3^).


## Density
```{r Uniplot_density}
summary(w$density)
plotVar(w$density, w)
```

The *density* variable follows a normal distribution (Shapiro-Wilk gives `r shapiro.test(w$density)$statistic` at P=`r shapiro.test(w$density)$p.value`). The Normal Q-Q plot below confirms this, but indicates also some heavier tails (hence the outliers in the boxplot).

```{r Uniplot_density_qq}
qqnorm(w$density); qqline(w$density)
```

## pH
```{r Uniplot_PH}
summary(w$pH)
plotVar(w$pH, w)
```

The *pH* variable also follows a normal distribution (Shapiro-Wilk gives `r shapiro.test(w$pH)$statistic` at P=`r shapiro.test(w$pH)$p.value`). The Normal Q-Q plot below confirms this, but indicates also some heavier right tail (hence the outliers in the boxplot).

```{r Uniplot_ph_qq}
qqnorm(w$pH); qqline(w$pH)
```
 
The mean pH lies at 3.3 which is consistent with the observation that the wines of "Vinho Verde" are pretty acid and fresh.

## Sulfates
```{r Uniplot_sulfates}
summary(w$sulphates)
plotVar(w$sulphates, w)
```

The *sulfates* variable (measuring predominantly the amount of K~2~SO~4~) has a bell-shaped right-skewed distribution, with longer right tail. 

Normally fresh (not very old) wines contain around 0.4-0.7 g/dm^3^ of K~2~SO~4~ which is very well seen in the histogram (median 0.62).

## Alcohol
```{r Uniplot_alcohol}
summary(w$alcohol)
plotVar(w$alcohol, w)
```

The *alcohol* content shows a significant right-skewedness (skewness = `r skewness(w$alcohol)`). As for all right-skewed distributions, this is due to a value limit situated on the left. This limit is the stipulation of the European legislation for minimum alcohol content to be 8.5%. The maximum cannot surpass 15%. We see this range clearly in the statistics above.


## Quality

The *quality* variable is categorical, so we will plot it in a barplot:

```{r Uniplot_quality}
summary(w$quality)
qplot(w$quality, color=I("black"), fill=I("orange"))
```

We see that the majority of wines are in the middle quality range.

# Univariate Analysis

### What is the structure of your dataset?

The dataset contains 1599 observations of red wines from the Portuguese region "Vinho Verde". Each observation has 11 inputs (chemical measurements) and 1 output (subjective sensory assessment of quality).

All laboratory measurements (*input* variables) are numeric and have the following meaning (in brackets are the units of measurement):

* **Fixed acidity** [g/dm^3^] - the amount of "good" non-volatile acids (e.g. malic, tartaric)
* **Volatile acidity** [g/dm^3^] - the amount of "bad" acids (mostly acetic acid)
* **Citric acid** [g/dm^3^] - the amount of citric acid
* **Residual sugar** [g/dm^3^] - the amount of sugar left after the fermentation has ended
* **Chlorides (mostly NaCl)** [g/dm^3^] - the amount of salts in the wine
* **Free sulfur dioxide (SO~2~)** [mg/dm^3^] - the free form of SO~2~ exists in equilibrium between molecular SO~2~ (as a dissolved gas) and bisulfite ion; it prevents microbial growth and the oxidation of wine.
* **Total sulfur dioxide (SO~2~)** [mg/dm^3^] - amount of free and bound forms of SO~2~; in low concentrations, SO~2~ is mostly undetectable in wine, but at free SO~2~ concentrations over 50 ppm, SO~2~ becomes evident in the nose and taste of wine.
* **Density** [kg/dm^3^] - the density of is close to that of water [1kg/dm3] depending on the percent alcohol and sugar content
* **pH** - describes the acidity of the wine: 0 (very acidic) to 14 (very basic)
* **Sulfates (mostly K~2~SO~4~)** [g/dm^3^] - a wine additive which can contribute to sulfur dioxide gas (SO~2~) levels, which acts as an antimicrobial and antioxidant agent.
* **Alcohol** [% by volume] - the percentage of alcohol content

The *output* variable is the factor **quality** having the following ordinal scale: 0 (lowest) to 10 (highest). The value of this variable is obtained as the median of three subjective sensory tasting assessments performed by different oenologists. The measured wines are in the range 3-8, i.e. no wine was classified as "very bad" or "excellent".


### What is/are the main feature(s) of interest in your dataset?

We're interested in finding a relationship that can predict the wine *quality* based on the various *chemical* measurements. It is not very easy to make apriori assumptions as to which chemical variables have a significant effect on the sensory perception of the wine. Still, what comes first to mind is the *alcohol* content and the *pH*, both being aspects that are very easily perceived. Of the other chemical substances, the measured *chloride* contents is mostly below the detection threshold. Likewise, *sulphur dioxide (aka sulfites)* have neither smell, nor taste, so it is not very likely that they can directly determine the tasting assessment. On the other hand, the *sulphates* can have very different tastes depending on their concentration, as shown on the diagram below.

![](k2so4_taste.png)

### What other features in the dataset do you think will help support your investigation into your feature(s) of interest?

*Citric acid* gives a freshness to the wine, and as such will probably affect positively the tasting. Contrarily to it, the *acetic* acid (quantified by the *volatile.acidity* variable) will give an unpleasant characteristic vinegar taste. We have to keep in mind that higher acidity will correlate with low levels of pH, therefore it is important to distinguish the case when low pH is due to the bad "acetic" acid.

### Did you create any new variables from existing variables in the dataset?

A new categorical variable `sweetness` was created to classify each wine according to its residual sugar content. It has the following levels: "dry" < "medium dry" < "medium" < "sweet".

### Of the features you investigated, were there any unusual distributions? Did you perform any operations on the data to tidy, adjust, or change the form of the data? If so, why did you do this?

There are two rather normal distributions: *pH* and *density*.

Most of the distributions, however, are **right-skewed**. This normally happens when we measure quantities that cannot be below a given limit (e.g. due to some law requirements, as is the case with the alcohol contents). Such distributions can usually benefit from a **log** transformation, as this increases their normality. An example is given below for the *total SO~2~* variable.

Before the *log* transformation, the *total SO~2~* variable has a normality statistics, as determined by the Shapiro-Wilk test, equal to `r shapiro.test(w$total.sulfur.dioxide)$statistic`. After the *log* transformation, Shapiro-Wilk gives `r shapiro.test(log10(w$total.sulfur.dioxide))$statistic`, i.e. the transformed variable has more normal distribution. The histograms before-and-after below confirm this:

```{r Univariate_xform2normality_SO2}
# Shapiro-Wilk before log xform
sw1 = round(shapiro.test(w$total.sulfur.dioxide)$statistic, digits=2)

# Shapiro-Wilk after log xform
sw2 = round(shapiro.test(log10(w$total.sulfur.dioxide))$statistic, digits=2)

g1 <- ggplot(aes(x=w$total.sulfur.dioxide), data=w) +
  geom_histogram(fill="blue", color="black", alpha=0.5) + 
  ggtitle(SO[2] ~ "before log xform") +
  annotate("label", label=paste0("Shapiro-Wilk = ", sw1), x=200, y=300)

g2 <- ggplot(aes(x=w$total.sulfur.dioxide), data=w) +
  geom_histogram(fill="blue", color="black", alpha=0.5) +
  scale_x_log10() + 
  xlab("log10(w$total.sulfur.dioxide)") + 
  ggtitle(SO[2] ~ "after log xform") +
  annotate("label", label=paste0("Shapiro-Wilk = ", sw2), x=130, y=120)

grid.arrange(g1, g2, ncol=2)

```


The most unusual distributions is the one of the *citric acid*. For didactic purposes, an attempt will be made to bring to normalization the distribution of the *citric acid*. One way to do this is to use the Box-Cox transformation, which is a type of *Power Transform* (as discussed [here](https://en.wikipedia.org/wiki/Power_transform) used frequently in many areas involving statistical analysis).

First, we plot the Q-Q normality plot of the original *citric acid* variable. It shows a rather non-normal distribution.

```{r Univariate_citricacid_qq}
# Normal probability plot for original variable
citric.acid.cleaned <- subset(w, citric.acid!=0)$citric.acid
qqnorm(citric.acid.cleaned); qqline(citric.acid.cleaned)
```

Then we perform the Box-Cox transformation with a plot of the Log-Likelihood profile

```{r Univariate_citricacid_boxcox}
# Illustration of Log-Likelihood profile
boxcox(citric.acid.cleaned ~ 1)	            

# Estimaton of Box-Cox lambda
pt <- powerTransform(citric.acid.cleaned)    

# Box-Cox transformation
citric.acid.transformed <- bcPower(citric.acid.cleaned, pt$lambda)	
```

Finally we plot the Q-Q plot for the transformed variable, as well a superposition of the original and transformed densities.

```{r Univariate_citricacid_plots}

# Normal probability plot for transformed variable
qqnorm(citric.acid.transformed); qqline(citric.acid.transformed)

ca <- data.frame(cac=citric.acid.cleaned, cat=citric.acid.transformed)
ggplot(data=ca) + geom_density(aes(x=cac), color = "blue") + 
                  geom_density(aes(x=cat), color="red") + 
				  xlab("Box-Cox transformed (red) vs. original (blue) distribution of citric.acid")

```

It seems that the Box-Cox transformation in this case does not produce a very convincing result...


# Bivariate Plots Section

To achieve a quick overview of all bi-variate relations, we'll produce a scatterplot matrix:

```{r Bivariate_Plots_ggpairs}

ggpairs(w[, 1:12], axisLabels = "internal", title="Red Wines",
        diag=list(continuous="density"), showStrips = NULL)

```


From the boxplots in this matrix we easily see that our variable of interest (*quality*) has very pronounced **positive correlation** with *citric acid*, *sulphates* and *alcohol*. It has **negative correlation** with *volatile acidity*, *chlorides*, *density* and *pH*. Its relation to the rest of the input variables seems less clearly defined. 

A better view of the dependence of *quality* on the input variables can be obtained from the figures below. They plot conditionally the median of each input variable at each level of *quality*:

```{r Bivariate_Plots_quality_cond}

plotStat <- function(x) {
  # Clean the name of the input variable
  yname <- strsplit(deparse(substitute(x)),"$",fixed=TRUE)[[1]][2]
  yname <- paste0("median of\n", yname)
  
  summary.func <- median
  
  ggplot(aes(x=as.numeric(quality), y=x), data=w) +
        geom_line(stat="summary", fun.y=summary.func) + 
        geom_point(stat="summary", fun.y=summary.func) + 
        ylab(yname) + 
        xlab("quality") + 
        #geom_boxplot(aes(x=quality), outlier.shape = NA) + 
        scale_x_discrete(labels=levels(w$quality))
}

q1 <- plotStat(w$alcohol)
q2 <- plotStat(w$citric.acid)
q3 <- plotStat(w$sulphates)
q4 <- plotStat(w$pH)
q5 <- plotStat(w$volatile.acidity)
q6 <- plotStat(w$density)
q7 <- plotStat(w$chlorides)
q8 <- plotStat(w$total.sulfur.dioxide)
q9 <- plotStat(w$residual.sugar)
q10 <- plotStat(w$fixed.acidity)
grid.arrange(q1,q2,q3,q4,q5,q6,q7,q8,q9,q10, ncol=2)
```

For an easier identification of the remaining significant correlations, a correlogram can help:

```{r Bivariate_Plots_corrgram}
corrgram(w,lower.panel=corrgram::panel.ellipse, upper.panel=panel.shade,
         diag.panel=panel.density)
```

# Bivariate Analysis

### Talk about some of the relationships you observed in this part of the investigation. How did the feature(s) of interest vary with other features in the dataset?

We see a very clear trend of increasing sensory quality with higher *alcohol* content. Amazingly, a similar trend is seen for the *sulphates*. *Volatile acidity* correlates negatively with quality, which was expected, given the unpleasant taste of the acetic acid. *Citric acid* on the other hand has a positive correlation, which is also not surprising, giving its "freshness" sensory effect. An interesting observation is that an increase in the *chlorides* leads to quality deterioration, even if the amounts are below the taste thresholds. The other variables--*fixed acidity*, *SO~2~* contents, and *residual sugar* do not have a clear relationship with the quality perception.

### Did you observe any interesting relationships between the other features (not the main feature(s) of interest)?

The correlogram shows pretty strong **positive correlation** (blue color) between:

* *Fixed acidity* and *citric acid* (cor=`r cor(w$fixed.acidity, w$citric.acid)`)---not surprising, since the amount of citric acid is already included in the measurement of the total "good" acids content.

* *Fixed acidity* and *density* (cor=`r cor(w$fixed.acidity, w$density)`)---this is due to the fact that the three main acids in wine (citric, malic and tartaric) have higher density than water (1.67, 1.61 and 1.79 g/cm^3^), therefore their presence increases the overall density of the wine.

* The two *SO~2~* measurements (cor=`r cor(w$free.sulfur.dioxide, w$total.sulfur.dioxide)`)---normal, since the free SO~2~ is included also in the total measurement.

* *Residual sugar* and *density* (cor=`r cor(w$residual.sugar, w$density)`)---as sugar is heavier than water (1.587 Kg/L vs. 1.000 kg/L), its presence tends to increase the overall density of the wine.

Strong **negative correlation** (red color) was found between:

* *Fixed acidity* and *pH* (cor=`r cor(w$fixed.acidity, w$pH)`)---as expected, since higher acidity manifests itself in lower pH.

* The same for *citric acid* and *pH* (cor=`r cor(w$citric.acid, w$pH)`).

* *Density* and *alcohol* content (cor=`r cor(w$density, w$alcohol)`)---since alcohol has lower specific density than water (0.780 kg/L compared to 1.000 kg/L), its presence tends to reduce the overall density (all other factors being equal).

Somewhat unexpected is the positive correlation seen for *volatile acidity* (acetic acid) and *pH* (normally all acids cause lower pH). This can be due to the following phenomenon ([see here](http://www.aromadictionary.com/articles/volatileacidity_article.html)): The "acetobacter aceti" bacteria responsible for the vinegar fermentation and the production of acetic acid thrives in wines with lower fixed acidity and SO~2~ levels. Therefore, wines with higher volatile acidity will tend to have lower fixed acidity (as we see in the negative correlation between fixed/citric and volatile acidity below). 

```{r Bivariate_Plots_fixedvolac}

# Limit a bit the data
va.p95 <- quantile(w$volatile.acidity, 0.95)
fa.p95 <- quantile(w$fixed.acidity, 0.95)

ggplot(aes(x=volatile.acidity, y=fixed.acidity), 
       data=subset(w, volatile.acidity < va.p95 & fixed.acidity < fa.p95)) + 
  geom_point() + geom_smooth(method="lm") +
  ggtitle("Negative correlation between fixed and volatile acidity")

```

This lower fixed acidity probably is not offset by the higher content of volatile acidity (acetic acid is a very weak acid), and therefore the pH tends to rise. This acidity-pH relationship is illustrated in the diagrams below:

```{r Bivariate_Plots_acidityPH}

g1 <- ggplot(aes(x=fixed.acidity, y=pH), data=w) + 
            geom_point(alpha=0.5) + 
            stat_smooth() + 
            annotate("text", label="Expected", x=12, y=4)

g2 <- ggplot(aes(x=volatile.acidity, y=pH), data=w) + 
            geom_point(alpha=0.5) +
            stat_smooth() + 
            annotate("text", label="Unexpected", x=1.2, y=4)

grid.arrange(g1, g2, ncol=2, top="Expected vs. unexpected effect of acidity on the pH")

```


### What was the strongest relationship you found?

Visually judging from the plots above, the strongest relationship could be the one between the amount of *citric acid* and *quality*.


# Multivariate Plots Section

An interesting experiment is to superimpose the density plots of the different variables that can be assumed to be predictors, conditional to the *quality* factor.

```{r Multivariate_Plots}

# Plot densities of an variable conditioned by the "quality" factor
plotDensity <- function(x) {
  # Extract the name of the variable
  xname <- strsplit(deparse(substitute(x)),"$",fixed=TRUE)[[1]][2]
  
  ggplot(aes(x=x, fill=quality), data=w) + 
		geom_density(alpha=0.4, color="black") + 
		scale_fill_brewer(type="qual") + 
		xlab(xname)
}

# Arrange several similar plots in a grid, using a common legend
# Code from: https://github.com/hadley/ggplot2/wiki/Share-a-legend-between-two-ggplot2-graphs
grid_arrange_shared_legend <- function(...) {
    plots <- list(...)
    g <- ggplotGrob(plots[[1]] + theme(legend.position="right"))$grobs
    legend <- g[[which(sapply(g, function(x) x$name) == "guide-box")]]
    width <- sum(legend$width)
    grid.arrange(
        do.call(arrangeGrob, lapply(plots, function(x)
            x + theme(legend.position="none"))),
        legend,
        ncol = 2,
        widths = grid::unit.c(unit(1, "npc") - width, width))
}



p1 <- plotDensity(w$alcohol)
p2 <- plotDensity(w$citric.acid)
p3 <- plotDensity(w$volatile.acidity)
p4 <- plotDensity(w$sulphates)

grid_arrange_shared_legend(p1,p2,p3,p4)

```

Another possibility is to visually explore a given chemical measurement across both quality and sweetness levels. This can be justified since the sweetness is one of the first factors by which people evaluate wines.

```{r Multivariate_sweetness_quality_facets}
ggplot(w, aes(x = 0, y = pH)) +
  geom_boxplot(size = .75) +
  geom_jitter(alpha = .2, color="blue") +
  facet_grid(sweetness ~ quality) +
  theme(axis.text.x = element_blank(), 
        axis.title.x=element_blank(), 
		axis.ticks.x=element_blank())
		
ggplot(w, aes(x = 0, y = alcohol)) +
  geom_boxplot(size = .75) +
  geom_jitter(alpha = .2, color="blue") +
  facet_grid(sweetness ~ quality) +
  theme(axis.text.x = element_blank(), 
        axis.title.x=element_blank(), 
		axis.ticks.x=element_blank())
```

One issue with these plots is that there are very few observations including "medium" wines--it would be best probably to completely ignore the visualizations for this factor level.

# Multivariate Analysis

### Talk about some of the relationships you observed in this part of the investigation. Were there features that strengthened each other in terms of looking at your feature(s) of interest?

The MV plots confirmed the already observed relationships of some variables to *quality*. In this case we see clearly from the density plots that the distribution modes of these variables change monotonously (increase for *citric.acid*, *alcohol* and *sulphates*; decrease for *volatile.acidity*) across the increasing levels of *quality*.


### Were there any interesting or surprising interactions between features?

From the density plots we also see that the variances of some of the variables (like *citric.acid* and *sulphates*) at different *quality* levels are very similar. For others (*volatile.acidity* and *alcohol*) they are different, and interesting enough, they differ in opposite ways---*alcohol* variance increases with quality level, while *volatile.acidity*'s variance decreases. 

What this means is that the lower-quality wines can have very different amounts of acetic acid; meaning in turn that there is another more potent factor that comes into play and downgrades the wine. One such factor could be the amount alcohol--if it is low, then the wine goes to the bad side, even if there is little acetic acid in it. 

On the reverse, high quality wines can have very different values of alcohol content. This could be due to another factor that keeps the quality high despite the varying alcohol content. Maybe this is a low amount of acetic acid.

To test this hypothesized correlation between alcohol and acetic acid levels we can plot their scatterplot faceted by the quality level.

```{r Multivariate_acidity_alcohol_scatterplot}

ggplot(data=w, aes(x=volatile.acidity, y=alcohol)) + 
	geom_point() + geom_smooth(method=lm, color="red") + 
	facet_wrap(~quality)

```

Indeed we see that there is significant correlation between alcohol and acetic acid content at the two quality extremes. So, the "very bad" quality wines steadily feature a low alcohol content; similarly, the "excellent" wines mostly have low volatile acidity.



### OPTIONAL: Did you create any models with your dataset? Discuss the strengths and limitations of your model.

Since the output variable is categorical (and have an ordinal scale), we have to consider an **ordered logistic regression** (see [here](http://www.ats.ucla.edu/stat/r/dae/ologit.htm)) approach to modeling the *quality* behavior. In other words we cannot use a method like "lm" or OLS (ordinary least squares) regression which operate on a continuous dependent variable.

We will use the `polr` command from the MASS package to estimate an *ologit* regression model. This command relies on the "proportional odds assumptions", i.e. it assumes the relationships between all pairs of outcome groups to be the same (in a robust study this is something to be tested, however it is far beyond the scope of the course).
 
In choosing the predictor variables for the regression, it is important that they are not correlated. I.e. it is of no use feeding the model both with *total.sulfur.dioxide* and *free.sulfur.dioxide*. As the analyses above shown the *quality* output is considerably affected by predictors such as *citric.acid*, *volatile.acidity*, *sulphates*, and *alcohol*. We will create a number of *proportional odds* regression models, using different combinations of predictors, and will compare their predictive strengths. The goodness-of-fit is measured via an invented indicator--predict.rate--which is simply the percentage of correctly predicted quality values against the total number of observations (another possible measure could be for example MAD (mean absolute deviation)).

The models will try are the following:

* quality ~ citric.acid
* quality ~ citric.acid + volatile.acidity
* quality ~ citric.acid + volatile.acidity + alcohol
* quality ~ sqrt(citric.acid) + volatile.acidity + alcohol
* quality ~ citric.acid + volatile.acidity + log10(alcohol)
* quality ~ citric.acid + volatile.acidity + alcohol + sulphates
* quality ~ citric.acid + volatile.acidity + log10(alcohol) + sulphates
* quality ~ volatile.acidity + alcohol + sulphates
* quality ~ alcohol + pH
* quality ~ alcohol + pH + volatile.acidity
* quality ~ log10(alcohol) + pH + log10(volatile.acidity)

After fitting these models, a summary table will be printed sorted by increasing value of the "prediction rate".

```{r Multivariate_ologit}

# Define model formulas
f <- c("quality ~ citric.acid",
       "quality ~ citric.acid + volatile.acidity",
       "quality ~ citric.acid + volatile.acidity + alcohol",
       "quality ~ sqrt(citric.acid) + volatile.acidity + alcohol",
       "quality ~ citric.acid + volatile.acidity + log10(alcohol)",
       "quality ~ citric.acid + volatile.acidity + alcohol + sulphates",
       "quality ~ citric.acid + volatile.acidity + log10(alcohol) + sulphates",
       "quality ~ volatile.acidity + alcohol + sulphates",
       "quality ~ alcohol + pH",
       "quality ~ alcohol + pH + volatile.acidity",
       "quality ~ log(alcohol) + pH + volatile.acidity",
       "quality ~ log10(alcohol) + pH + log10(volatile.acidity)")
        
# This data.frame will contain the result of each model fitting
models <- data.frame(formula=character(),
                 aic=double(),
                 predict.rate=double(),
                 row.names = NULL,
                 stringsAsFactors=FALSE)
        
# Fit and explore each model
for (mf in f) {
    # Fit the model
    m <-  polr(mf, data=w, Hess=T)
    # Run model prediction on the initial dataset
    w.m <- cbind(w, predict(m, w, type = "probs"))
    # Determined predicted quality based on model's odds predictions
    w.m$predicted.quality <- apply(w.m, 1, function(x) which.max(x[c(14:19)])+2)
    # Add a variable to the dataset saying if the predicted quality is a match
    w.m <- mutate(w.m, match=predicted.quality==quality)
    # Calculate the proportion of successful predictions
    rate.m <- count(w.m[w.m$match==T,]) / nrow(w.m)
    
    # Append the current models' results to the results data.frame
    models <- rbind(models, c(formula=mf, aic=extractAIC(m)[2], 
                              predict.rate=rate.m*100))
    models$formula <- as.character(models$formula)
}

row.names(models) <- NULL # Reset the row index

# Print the models results
grid.table(models[order(models$predict.rate.n),])

best_model <- models[models$predict.rate.n == max(models$predict.rate.n),]
```

According to the table above, the best model (i.e. the one having the best prediction rate) is:

```{r, Models_best}
best_model$formula
```

It also has a relatively low AIC (Akaike Information Criterion), meaning that its "difficulty (information loss) to goodness-of-fit" ratio is one of the better among the tried models.

The coefficients and other fitting statistics of this model are:

```{r model_coeff}
m <-  polr(best_model$formula, data=w, Hess=T)
summary(m)
```

We see that the predictive power of these models is far from satisfactory (< 60%). Probably, we can have better results using a higher-order regression model or some machine learning approach---for example, **Random Forests** or **Support Vector Machines (SVM)** come to mind.

------

# Final Plots and Summary

### Plot One
```{r fig.height=9, Plot_One}

plotOne <- function(w, v) {
  name <- substitute(v)[[3]]
  ggplot(data=w, aes(x=v)) + geom_density(fill="green",alpha=0.5) + 
      geom_vline(aes(xintercept = median(v)), color="red") +
      xlab(name)
}

r1 <- plotOne(w, w$fixed.acidity)
r2 <- plotOne(w, w$volatile.acidity)
r3 <- plotOne(w, w$citric.acid)
r4 <- plotOne(w, w$pH)
r5 <- plotOne(w, w$density)
r6 <- plotOne(w, w$residual.sugar)
r7 <- plotOne(w, w$total.sulfur.dioxide)
r8 <- plotOne(w, w$free.sulfur.dioxide)
r9 <- plotOne(w, w$alcohol)
r10 <- plotOne(w, w$sulphates)
r11 <- plotOne(w, w$chlorides)
r12 <- ggplot(data=w, aes(x=quality)) + geom_bar(fill="green",color="black",alpha=0.5)

grid.arrange(r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, ncol=2, 
             top=paste0("Distributions of the physicochemical measurements of red wines",
                        " (red lines denote medians)"),
             heights=rep(unit(1.3,"inch"), 6))
```

### Description One

As a first plot we will show the distribution (as a density) of all the variables. This is the most direct way to get an immediate all-encompasing overview of the major mono-variate properties of the measurements. 

We can glean the following information about the variables and their behavior (summarized here, treated in detail above in the text):

* Some variables visually seem to have a pretty *normal* distribution. These include: *pH*, *density*, *residual sugars*, *chlorides*. The Shapiro-Wilk test gives the following normality statistics for them:

Variable        | Shapiro-Wilk statistics               | p-Value
----------------|---------------------------------------|-------------------------------------
chlorides       | `r shapiro.test(w$chlorides)$st`      | `r shapiro.test(w$chlorides)$p`
density         | `r shapiro.test(w$density)$st`        | `r shapiro.test(w$density)$p`
pH              | `r shapiro.test(w$pH)$st`             | `r shapiro.test(w$pH)$p`
residual sugars | `r shapiro.test(w$residual.sugar)$st` | `r shapiro.test(w$residual.sugar)$p`

In fact this test confirms the normality only of *pH* and *density*, but not of the other two variables. This can be because they have very long and thin right tails (i.e. a lot of outliers). This is really visible on the boxplots for these two measurements in the mono-variate section above. If we repeat the Shapiro-Wilk test only on the data below the 95% quantile, we can really see that the bulk of *chloride* and *residual sugar* data is normally distributed:

```{r shapiro_wilk_sugar_chl}
chlorides.q95 <- subset(w$chlorides, w$chlorides < quantile(w$chlorides,0.95))
chlorides.shapiro.s <- shapiro.test(chlorides.q95)$st
chlorides.shapiro.p <- shapiro.test(chlorides.q95)$p

residual.sugar.q95 <- subset(w$residual.sugar, w$residual.sugar < quantile(w$residual.sugar,0.95))
residual.sugar.shapiro.s <- shapiro.test(residual.sugar.q95)$st
residual.sugar.shapiro.p <- shapiro.test(residual.sugar.q95)$p

```

Variable               | Shapiro-Wilk statistics               | p-Value
-----------------------|---------------------------------------|-------------------------------------
chlorides < 95%        | `r chlorides.shapiro.s`               | `r chlorides.shapiro.p`
residual sugars  < 95% | `r residual.sugar.shapiro.s`          | `r residual.sugar.shapiro.p`

The *normality* of such physicochemical measurements indicates that there is a **naturally progressing** physical/chemical phenomenon responsible for the value of the given measurement. Such a phenomenon could be the fermentation (which can be viewed as the summed and overlapping action of millions of bacteries), or the intake of chlorides from the soil (which is the result of the osmotic action of the millions of small root hairs of the vine plant).  

* The rest of the measurements feature predominantly right-skewed distributions. The following table lists the skeweness of these variables (values > 0 indicate right-skewedness):

Variable               | Pearson skewness           
-----------------------|--------------------------------
alcohol                | `r skewness(w$alcohol)`
citric.acidity         | `r skewness(w$citric.acid)`
fixed.acidity          | `r skewness(w$fixed.acidity)`   
volatile.acidity       | `r skewness(w$volatile.acidity)`
free.sulfur.dioxide    | `r skewness(w$free.sulfur.dioxide)`
total.sulfur.dioxide   | `r skewness(w$total.sulfur.dioxide)`
sulphates              | `r skewness(w$sulphates)`   
volatile.acidity       | `r skewness(w$volatile.acidity)`

The right-skewedness, contrary to the normal distribution, is more typical of processes having an **artificially** set lower limit---this could be a legislative requirement (as for the alcohol content), or technological depedendancy (such as the minimal levels of SO~2~ needed for reliable protection of the wine)

* Finally, the *citric acid* has a what appears to be tri-modal distribution, sharply cut to the left due to the measurement's limited precision. The three peaks in the distribution were seen to coincide with certain "round-number" levels of citric acid contents--indicative of the winemakers' artificial adding of this acid to correct the overall acidity of the wine.


### Plot Two
```{r Plot_Two}
corrgram(w,lower.panel=corrgram::panel.conf, upper.panel=panel.shade)
title("Correlations between the measured quantities")
```

### Description Two

As a second plot we will provide a correlation matrix. This is the quickest and most direct way to view the bi-variate relationships (quantified as correlations) between the variables. Red is negative correlation, blue is positive. The more saturated a color is, the stronger the correlation. The correlation coefficients are given with their 95% CI. As identified in the section for Bi-variate analysis, there is a physical/chemical causation explaining most of the strong correlations (e.g. higher fixed acidity translates into a lower pH).

The following table gives the strongest positive correlations:
```{r fig.height=3, cor_pos}
# Get all cross-corellations
w.corr <- cor(w[-(12:13)])

# Set auto-correlations to 0
w.corr[w.corr == 1] <- 0

# Sort and remove duplicates (the correlation matrix is symetrical!)
w.corr.sorted <- sort(w.corr)
w.corr.sorted <- w.corr.sorted[-(1:length(w.corr.sorted))*2]

# Obtain the variable names for each correlation pair
corr.names <- sapply(w.corr.sorted, function(x) which(w.corr==x, arr.ind=T))
corr.var1 <- sapply(corr.names, function(x) rownames(x)[1])
corr.var2 <- sapply(corr.names, function(x) rownames(x)[2])
xcor <- data.frame(corr_coeff=w.corr.sorted, var1=corr.var1, var2=corr.var2)

# Print the highest positive correlations
grid.table(head(xcor[order(xcor$corr_coeff,decreasing = T),]))
```

As already seen, the strongest positive correlations are between measurements that include/repeat each other, as well as between *density* and *fixed.acidity* (physically explainable given the densities of the wine acids).

The following table gives the strongest negative correlations:
```{r fig.height=3, cor_neg}
# Print the highest negative correlations
grid.table(head(xcor))
```

Strongest negative correlation is seen between *pH* and the *acidities* (since pH is a measurement of the acidity), and between *alcohol* and *density* (again explained with the relative density of alcohol).

Identifying the correlated variables is important before performing a regression modeling, since we have to avoid feeding the model with predictors that are correlated (danger of **multicollinearity**).


### Plot Three
```{r fig.height=9, Plot_Three}
grid.arrange(q1,q2,q3,q4,q5,q6,q7,q8,q9,q10, ncol=2,
             heights=rep(unit(1.3,"inch"), 6),
             top = "Evolution of the medians of each measurement, conditional on quality")
```

### Description Three

The final plot prepares us to select the variables that can serve as inputs for a quality-predicting model (like logistic regression or machine learning algorithms)

In this plot we show how the different physicochemical quantities behave at different quality levels. For this we draw their median values conditioned on the quality level. 

We see directly that some of the quantities have a monotonous relationship to quality. These  physicochemical properties make the best candidates for predictors of the *quality* output.

The following table summarizes the observed relationships:

Input variable    | Relationship to *quality*
------------------|--------------------------
fixed acidity     | non-monotonous
volatile acidity  | decreasing, perfectly monotonous
citric acid       | increasing, perfectly monotonous
free SO~2~        | non-monotonous
total SO~2~       | non-monotonous
residual sugar    | non-monotonous
sulphates         | increasing, monotonous
chlorides         | decreasing, somewhat monotonous
alcohol           | increasing, monotonous
pH                | decreasing, somewhat monotonous
density           | decreasing, somewhat monotonous

We see that the best quality predictors candidates are *volatile acidity*, *citric acid*, *sulphates* and *alcohol*. The previous correlation analysis also shows that there is no strong correlation between these quantities, so any combination of them can serve as an input to a regression model. 

------

# Reflection

Finding a way to predict the sensory quality of wines based on their physicochemical properties can fulfill a dream of winemakers and oenologists.

Using datamining techniques operating on large freely available datasets of wine measurements can probably achieve this.

We can go even further and imagine models that can predict the origin and sort of the grapes from the chemical measurements; or even the climatic quality of the vintage year.

With the given dataset of red wine observations from the Vinho Verde region, it was already possible to determine some chemical properties that can be used as predictors for the quality output. The most apparent ones are the *alcohol content*, the *volatile acidity*, the amount of *citric acid* and of *sulphates*. Especially the latter was an unexpected relationship.

An attempt was made to obtain an ordinal proportional-odds  regression model, using the thus identified predictors. The goodness-of-fit of the found model was not deemed  satisfactory, suggesting that the use of more advanced methods like Random Forests can lead to better results.

Unfortunately the dataset does not include any measurements of *tannin* content; yet tannins (the natural polyphenols giving the astringent taste of wine) are very important for the sensory perception of wines.


# Bibliography

[When a wine is salty, and why it shouldn't be](http://wineoscope.com/2015/10/02/when-a-wine-is-salty-and-why-it-shouldnt-be/)

[Chloride concentration in red wines: influence of terroir and grape type](http://www.scielo.br/scielo.php?pid=S0101-20612015000100095&script=sci_arttext)

[Vinho Verde on Wikipedia](https://en.wikipedia.org/wiki/Vinho_Verde)

[Box-Cox Normality Transformation](http://www.itl.nist.gov/div898/handbook/eda/section3/boxcoxno.htm)

Grainger K., Tattersall H., Wine Production and Quality, Wiley, 2016
